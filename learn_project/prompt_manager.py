#!/usr/bin/env python3
"""
Prompt Manager for LEARN system
Handles creation and management of prompt markdown files
"""

import os
import json
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional


class PromptManager:
    """Manages prompt markdown files for LEARN system."""
    
    def __init__(self, base_path: str = "learn_project"):
        self.base_path = Path(base_path)
        self.prompt_dir = self.base_path / "prompt"
        self.prompt_dir.mkdir(parents=True, exist_ok=True)
        
        # Create metadata file if it doesn't exist
        self.metadata_file = self.prompt_dir / "metadata.json"
        if not self.metadata_file.exists():
            self._init_metadata()
    
    def _init_metadata(self):
        """Initialize metadata file."""
        metadata = {
            "created": datetime.now().isoformat(),
            "last_updated": datetime.now().isoformat(),
            "prompt_count": 0,
            "prompts": []
        }
        with open(self.metadata_file, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, indent=2, ensure_ascii=False)
    
    def _load_metadata(self) -> Dict:
        """Load metadata from file."""
        with open(self.metadata_file, 'r', encoding='utf-8') as f:
            return json.load(f)
    
    def _save_metadata(self, metadata: Dict):
        """Save metadata to file."""
        metadata["last_updated"] = datetime.now().isoformat()
        with open(self.metadata_file, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, indent=2, ensure_ascii=False)
    
    def get_next_prompt_number(self) -> int:
        """Get the next prompt number."""
        metadata = self._load_metadata()
        return metadata["prompt_count"]
    
    def create_general_prompt(self, topic: str, mode: str, style: str) -> Path:
        """Create a prompt markdown for general topic learning."""
        prompt_num = self.get_next_prompt_number()
        prompt_path = self.prompt_dir / f"{prompt_num}.md"
        
        # Generate detailed prompt content
        prompt_content = f"""# Learning Prompt #{prompt_num}: {topic}

## Metadata
- **Topic**: {topic}
- **Mode**: {mode}
- **Style**: {style}
- **Type**: General Topic Learning
- **Created**: {datetime.now().isoformat()}

## Generated Prompt

As an expert programming educator and software engineer, your task is to create a comprehensive learning project for the topic: **{topic}**.

### Project Requirements

**Learning Mode**: {mode}
- If Beginner: Focus on core concepts and simplest usage
- If Advanced: Include more complex or advanced techniques  
- If Practical: Driven by a small, integrated project

**Explanation Style**: {style}
- If Rigorous: Accurate and professional
- If Witty: Use analogies, be light-hearted and humorous

### Deliverables Structure

Please create a complete project folder structure containing:

1. **README.md** - Project overview and setup instructions
2. **tutorial.md** - Main tutorial with step-by-step learning content
3. **questions.md** - Comprehensive questions organized by difficulty levels
4. **src/** - Example code and exercises directory
5. **.gitignore** - Appropriate for the project's language/framework

### Tutorial Content Requirements

- **Clear Structure**: Include table of contents and step-by-step instructions
- **Concept First**: Begin by explaining core concepts related to "{topic}"
- **Code Examples**: Provide concise, runnable, and well-commented code snippets
- **Mode Alignment**: Content should match the {mode} learning mode
- **Style Consistency**: Language should reflect the {style} explanation style

### Questions Requirements

- **Comprehensive Coverage**: Questions should cover all major concepts
- **Progressive Difficulty**: Start with foundational, progress to advanced
- **Interactive Format**: Use markdown collapsible sections for answers
- **Practical Application**: Include questions about real-world usage

### Example Code Requirements

- **Runnable**: Code should be independently executable
- **Relevant**: Functionality must demonstrate "{topic}" concepts
- **Well-Commented**: Critical sections should have explanatory comments
- **Progressive**: Start simple, build to more complex examples

## Implementation Instructions

1. Create the project structure as specified above
2. Generate comprehensive content for each file
3. Ensure all code examples are tested and functional
4. Make the tutorial engaging and appropriate for the target audience
5. Provide clear next steps for continued learning

---
*This prompt was generated by the LEARN system for structured learning content creation.*
"""
        
        # Save prompt file
        with open(prompt_path, 'w', encoding='utf-8') as f:
            f.write(prompt_content)
        
        # Update metadata
        metadata = self._load_metadata()
        metadata["prompt_count"] += 1
        metadata["prompts"].append({
            "number": prompt_num,
            "topic": topic,
            "mode": mode,
            "style": style,
            "type": "general",
            "path": str(prompt_path),
            "created": datetime.now().isoformat()
        })
        self._save_metadata(metadata)
        
        return prompt_path
    
    def create_paper_prompt(self, paper_path: str, mode: str, style: str, 
                          read_images: bool, max_pages: int, chapters: List[str],
                          pdf_markdown_paths: List[str]) -> Path:
        """Create a prompt markdown for paper learning."""
        prompt_num = self.get_next_prompt_number()
        prompt_path = self.prompt_dir / f"{prompt_num}.md"
        
        paper_name = Path(paper_path).stem
        
        # Generate references to PDF markdown files
        pdf_references = []
        for i, pdf_path in enumerate(pdf_markdown_paths):
            pdf_references.append(f"- **Chunk {i+1}**: `{pdf_path}`")
        
        pdf_refs_text = "\n".join(pdf_references) if pdf_references else "- No PDF markdown files generated yet"
        
        # Generate detailed prompt content
        prompt_content = f"""# Learning Prompt #{prompt_num}: Paper Analysis - {paper_name}

## Metadata
- **Paper**: {paper_name}
- **Paper Path**: {paper_path}
- **Mode**: {mode}
- **Style**: {style}
- **Type**: Paper Learning
- **Read Images**: {read_images}
- **Max Pages per Chunk**: {max_pages}
- **Chapters**: {', '.join(chapters)}
- **Created**: {datetime.now().isoformat()}

## PDF Content References

The following markdown files contain the extracted content from the PDF:

{pdf_refs_text}

## Generated Prompt

As an expert academic researcher and educator, your task is to create comprehensive learning materials based on the research paper: **{paper_name}**.

### Paper Processing Configuration

- **Image Analysis**: {'Enabled' if read_images else 'Disabled'}
- **Processing Mode**: {max_pages} pages per chunk
- **Focus Chapters**: {', '.join(chapters)}
- **Learning Mode**: {mode}
- **Explanation Style**: {style}

### Learning Materials to Create

#### 1. Main Tutorial (tutorial.md)
Create a comprehensive tutorial that covers:
- **Paper Overview**: Summary of main contributions and significance
- **Chapter-by-Chapter Analysis**: Detailed breakdown of each section
- **Key Concepts**: Important terminology and concepts explained
- **Methodology Deep Dive**: How the research was conducted
- **Results Interpretation**: What the findings mean and their implications
- **Critical Analysis**: Strengths, weaknesses, and limitations

#### 2. Section-Based Questions (questions.md)
Generate detailed questions organized by paper sections:

**Background Questions**:
- What problem does this paper address?
- Why is this problem important?
- What are the limitations of existing approaches?
- How does this work relate to prior research?

**Methodology Questions**:
- What is the core approach proposed?
- How does the methodology work step by step?
- What are the key innovations?
- What assumptions are made?

**Evaluation Questions**:
- What datasets/experiments were used?
- How do results compare to baselines?
- What are the key findings?
- What are the limitations of the evaluation?

**Future Work Questions**:
- What directions for future research are suggested?
- What improvements could be made?
- What are the broader implications?

#### 3. Chapter Tutorials (docs/ directory)
Create individual tutorials for each chapter:
{chr(10).join([f"- **{chapter.title()} Tutorial**: Focus on {chapter} aspects" for chapter in chapters])}

#### 4. Implementation Guide (src/ directory)
If applicable, provide:
- Code examples demonstrating key concepts
- Reproduction scripts for experiments
- Implementation templates

### Content Requirements

**Mode Alignment**: 
- **Beginner**: Focus on understanding core concepts and significance
- **Advanced**: Include technical details and implementation considerations
- **Practical**: Emphasize how to apply or build upon this work

**Style Consistency**:
- **Rigorous**: Academic precision and formal explanations
- **Witty**: Engaging explanations with analogies and accessible language

### Processing Instructions

1. **Read PDF Content**: Process the markdown files referenced above
2. **Extract Key Information**: Identify main contributions, methods, and results
3. **Organize by Sections**: Structure content according to paper organization
4. **Generate Comprehensive Materials**: Create all required files and directories
5. **Ensure Accessibility**: Make complex concepts understandable for the target audience

### Quality Checklist

- [ ] All major paper sections are covered
- [ ] Technical concepts are clearly explained
- [ ] Questions probe deep understanding
- [ ] Content matches specified mode and style
- [ ] Materials are well-organized and navigable
- [ ] Examples and applications are provided where relevant

---
*This prompt was generated by the LEARN system for academic paper learning.*
"""
        
        # Save prompt file
        with open(prompt_path, 'w', encoding='utf-8') as f:
            f.write(prompt_content)
        
        # Update metadata
        metadata = self._load_metadata()
        metadata["prompt_count"] += 1
        metadata["prompts"].append({
            "number": prompt_num,
            "topic": f"Paper: {paper_name}",
            "mode": mode,
            "style": style,
            "type": "paper",
            "paper_path": paper_path,
            "path": str(prompt_path),
            "pdf_references": pdf_markdown_paths,
            "created": datetime.now().isoformat()
        })
        self._save_metadata(metadata)
        
        return prompt_path
    
    def get_latest_prompt_path(self) -> Optional[Path]:
        """Get the path of the latest prompt file."""
        metadata = self._load_metadata()
        if metadata["prompt_count"] == 0:
            return None
        
        latest_num = metadata["prompt_count"] - 1
        return self.prompt_dir / f"{latest_num}.md"
    
    def list_prompts(self) -> List[Dict]:
        """List all prompts with their metadata."""
        metadata = self._load_metadata()
        return metadata["prompts"] 